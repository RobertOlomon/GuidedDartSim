%% EstimateDartState.m
% This script simulates sensor-based state estimation for a guided dart.
% It uses simulated accelerometer data (to derive pitch and roll via the gravity vector)
% and simulated camera measurements of the guiding light (to derive yaw error)
% to form an estimate of the dart's orientation.
% In addition, it simulates an inertial position estimate by integrating a noisy acceleration.
%
% The ideal dart trajectory (lookup table) is loaded from LookupTable.mat.
% True state data is generated by running a GuidedDartSim simulation.
% Finally, the script plots the true trajectory and the estimated trajectory,
% overlaying the dart basis vectors every ~0.3 seconds.

clear; clc; close all;

%% Load the Ideal Trajectory Lookup Table
% LookupTable columns: [time, u, v, ideal_pitch, distance]
load('LookupTable.mat', 'lookupTable');

% Define camera intrinsics (must match those used when generating the lookup table)
imageWidth = 1280;
hfov = deg2rad(85);
fx = (imageWidth/2) / tan(hfov/2);

%% Run Guided Dart Simulation to get the True State
% Set up simulation parameters (example values)
Pitch = deg2rad(45);  
Yaw = 0.126689635808396;  
Angle = [Pitch; Yaw; 0];  % [pitch; yaw; roll]
DBVelocity = [0; 0; 16.38];
Position = [4.225; 0.94; 0.5852483];
Mass = 0.208;
InertiaMatrix = [0.00086057, 0, 0.00000021;
                 0, 0.00086107, 0.00000313;
                 0.00000021, 0.00000313, 0.00009604];

% Create a simulation object with MobileBase fixed (for simplicity)
sim = GuidedDartSim(Angle, DBVelocity, Position, Mass, InertiaMatrix, ...
    'DisplayBasisVectors', false, 'RunningOptimization', false, 'TargetingBase', true, ...
    'MobileBase', 'fixed');
sim.run();

N = length(sim.PlotTime);
dt = sim.Timestep;
truePos = sim.PlotPosition;       % True positions (Nx3)
trueBasis = sim.PlotDartBasis;      % True dart orientation (cell array)

%% Simulate Sensor Measurements for Orientation
% Noise parameters:
sigma_g = 0.05;     % standard deviation for gravity measurement noise (m/s^2)
sigma_cam = 1;      % standard deviation for camera measurement noise (pixels)

% Preallocate estimated Euler angles: [roll, pitch, yaw] (using ZYX convention)
estEuler = zeros(N,3);

for k = 1:N
    % True dart orientation (rotation matrix)
    R_true = trueBasis{k};
    
    % Simulate accelerometer measurement: measure gravity in body frame.
    % True gravity in world: [0; -9.81; 0]. Transform to body frame.
    g_world = [0; -9.81; 0];
    g_body_true = R_true' * g_world;
    % Add noise:
    g_body_meas = g_body_true + sigma_g * randn(3,1);
    
    % Estimate roll and pitch from the measured gravity.
    % Common formulas: roll = atan2(g_y, g_z); pitch = atan2(-g_x, sqrt(g_y^2+g_z^2))
    roll_est = atan2(g_body_meas(2), g_body_meas(3));
    pitch_est = atan2(-g_body_meas(1), sqrt(g_body_meas(2)^2 + g_body_meas(3)^2));
    
    % Simulate camera measurement for yaw:
    % Find the nearest lookup table entry (by time).
    [~, idx_lut] = min(abs(lookupTable(:,1) - sim.PlotTime(k)));
    u_ideal = lookupTable(idx_lut, 2);
    % Simulate measured u-coordinate with noise:
    u_meas = u_ideal + sigma_cam * randn;
    % Compute yaw error (assume small angles): yaw_error = arctan((u_meas - u_ideal)/fx)
    yaw_est = atan((u_meas - u_ideal) / fx);
    
    % Store the estimated Euler angles (in ZYX order, where yaw is about Z)
    estEuler(k,:) = [roll_est, pitch_est, yaw_est];
end

%% Simulate Position Estimation via Accelerometer Integration
% For position, we assume that the accelerometer measures the true acceleration with noise.
% Compute true acceleration via finite differences (central difference).
trueAcc = zeros(N,3);
for k = 2:N-1
    trueAcc(k,:) = (truePos(k+1,:) - 2*truePos(k,:) + truePos(k-1,:)) / (dt^2);
end
% For endpoints, use forward/backward difference.
trueAcc(1,:) = (truePos(2,:) - truePos(1,:)) / dt;
trueAcc(N,:) = (truePos(N,:) - truePos(N-1,:)) / dt;

% Noise standard deviation for acceleration measurement:
sigma_acc = 0.2;  % m/s^2

% Simulate accelerometer measurement:
measAcc = trueAcc + sigma_acc * randn(size(trueAcc));

% Integrate acceleration to obtain estimated velocity and position.
estVel = zeros(N, 3);
estPos = zeros(N, 3);
estPos(1,:) = truePos(1,:); % assume known initial position
% Assume initial velocity from true state (or set to zero)
if N >= 2
    estVel(1,:) = (truePos(2,:) - truePos(1,:)) / dt;
end
for k = 1:N-1
    estVel(k+1,:) = estVel(k,:) + measAcc(k,:) * dt;
    estPos(k+1,:) = estPos(k,:) + estVel(k,:) * dt + 0.5 * measAcc(k,:) * dt^2;
end

%% Visualization: Plot True vs. Estimated Trajectories and Basis Vectors
figure;
hold on; grid on; axis equal;
xlabel('X (m)'); ylabel('Y (m)'); zlabel('Z (m)');
title('Dart Guidance: True (blue) vs. Estimated (red) Trajectory');

plot3(truePos(:,1),  truePos(:,3), truePos(:,2), 'b-', 'LineWidth', 2);
hold on
plot3(estPos(:,1),  estPos(:,3), estPos(:,2), 'r--', 'LineWidth', 2);

% Plot basis vectors every 0.3 seconds.
is = 0.3;
basis_indices = find(mod(sim.PlotTime, dt_basis) < dt);
scaleVec = 0.2;
for idx = basis_indices'
    % True basis vectors (blue)
    pos_true = truePos(idx,:)';
    R_true = trueBasis{idx};
    quiver3(pos_true(1), pos_true(2), pos_true(3), scaleVec*R_true(1,1), scaleVec*R_true(2,1), scaleVec*R_true(3,1), 'Color', 'b', 'LineWidth', 2);
    quiver3(pos_true(1), posdt_bas_true(2), pos_true(3), scaleVec*R_true(1,2), scaleVec*R_true(2,2), scaleVec*R_true(3,2), 'Color', 'b', 'LineWidth', 2);
    quiver3(pos_true(1), pos_true(2), pos_true(3), scaleVec*R_true(1,3), scaleVec*R_true(2,3), scaleVec*R_true(3,3), 'Color', 'b', 'LineWidth', 2);
    
    % Estimated basis vectors (red)
    pos_est = estPos(idx,:)';
    % Use the estimated Euler angles from estEuler (convert to rotation matrix using ZYX convention)
    yaw_est = estEuler(idx,3);
    pitch_est = estEuler(idx,2);
    roll_est = estEuler(idx,1);
    R_est = eul2rotm([yaw_est, pitch_est, roll_est], 'ZYX');
    quiver3(pos_est(1), pos_est(2), pos_est(3), scaleVec*R_est(1,1), scaleVec*R_est(2,1), scaleVec*R_est(3,1), 'Color', 'r', 'LineWidth', 2);
    quiver3(pos_est(1), pos_est(2), pos_est(3), scaleVec*R_est(1,2), scaleVec*R_est(2,2), scaleVec*R_est(3,2), 'Color', 'r', 'LineWidth', 2);
    quiver3(pos_est(1), pos_est(2), pos_est(3), scaleVec*R_est(1,3), scaleVec*R_est(2,3), scaleVec*R_est(3,3), 'Color', 'r', 'LineWidth', 2);
end

legend('True Trajectory', 'Estimated Trajectory');
title('Dart Guidance: True (blue) vs. Estimated (red) Trajectory');
hold off
